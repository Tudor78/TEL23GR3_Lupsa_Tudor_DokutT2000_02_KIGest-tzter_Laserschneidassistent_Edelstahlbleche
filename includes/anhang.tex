\addchap{Anhang}

\begin{lstlisting}[language=Python, caption={Interpolation begrenzter Lücken in 1D-Profilen}, label={lst:interp-limited-nans}]
def interpolate_limited_nans(vector, max_gap=5):
    """
    Interpoliert nur kleine NaN-Lücken (<= max_gap) mit weicher Spline-Interpolation.
    """
    vector = vector.copy()
    isnan = np.isnan(vector)
    indices = np.arange(len(vector))

    if not np.any(~isnan):
        return None

    nan_groups = []
    in_nan = False
    start = 0
    for i, val in enumerate(isnan):
        if val and not in_nan:
            in_nan = True
            start = i
        elif not val and in_nan:
            in_nan = False
            nan_groups.append((start, i - 1))
    if in_nan:
        nan_groups.append((start, len(vector) - 1))

    for start, end in nan_groups:
        gap_size = end - start + 1
        if gap_size <= max_gap:
            left = start - 1
            right = end + 1
            if left < 0 or right >= len(vector):
                continue
            if np.isnan(vector[left]) or np.isnan(vector[right]):
                continue

            # Verwende CubicSpline statt np.interp
            x_known = [left, right]
            y_known = [vector[left], vector[right]]
            cs = CubicSpline(x_known, y_known, bc_type='natural')
            interp_indices = indices[start:end+1]
            vector[start:end+1] = cs(interp_indices)

    return vector
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Achsweise Interpolation von NaNs in Matrizen}, label={lst:interp-nan-matrix}]
def interpolate_nan(matrix_in, axis=0, max_gap=5):
    """
    Interpoliert NaNs in einer Matrix entlang der gegebenen Achse mit Begrenzung.
    """
    matrix = matrix_in.copy()
    x, y = matrix.shape

    if axis == 0:
        for col_index in range(y):
            if np.isnan(matrix[:, col_index]).any():
                vec = interpolate_limited_nans(matrix[:, col_index], max_gap=max_gap)
                if vec is not None:
                    matrix[:, col_index] = vec
    else:
        for row_index in range(x):
            if np.isnan(matrix[row_index, :]).any():
                vec = interpolate_limited_nans(matrix[row_index, :], max_gap=max_gap)
                if vec is not None:
                    matrix[row_index, :] = vec
    return matrix
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Interpolation von X-, Y- und Z-Ebenen}, label={lst:interp-planes}]
def interpolate_planes(X, Y, Z, results_directory=None, max_gap=0.5):
    """
    Interpoliert X, Y, Z Ebenen entlang sinnvoller Achsen mit Lückenbegrenzung.
    """
    X_interpolated = interpolate_nan(X, axis=1, max_gap=max_gap)
    Y_interpolated = interpolate_nan(Y, axis=1, max_gap=max_gap)
    Z_interpolated = interpolate_nan(Z, axis=0, max_gap=max_gap)
    return X_interpolated, Y_interpolated, Z_interpolated
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Kapselnde 1D-Pipeline: begrenzte Interpolation mit optionaler Glättung}, label={lst:smooth-nan-values}]
def smooth_nan_values(x, z, max_nan_values_perc=0.4, max_gap=5, 
                      smoothing=True, window_length=7, polyorder=2):
    """
    Interpoliert NaN-Werte in z, aber nur bei kleiner Lückenanzahl
    und akzeptablem NaN-Anteil. Optional geglättet mit Savitzky-Golay.
    """
    z = np.copy(z)
    nan_indices = np.isnan(z)
    num_nans = np.sum(nan_indices)

    if num_nans / len(z) > max_nan_values_perc:
        return None

    z = interpolate_limited_nans(z, max_gap=max_gap)

    # Optional glätten
    if smoothing and z is not None and np.count_nonzero(~np.isnan(z)) > window_length:
        z = savgol_filter(z, window_length=window_length, polyorder=polyorder)

    return z
\end{lstlisting}

\begin{lstlisting}[language=Python, caption={Schließen kurzer Täler (Valleys) via begrenzter Interpolation}, label={lst:fill-small-valleys}]
def fill_small_valleys(z, window_size=30, depth_threshold=5.0, max_gap=0.5,
                       smoothing=True, smooth_window=7, polyorder=2):
    """
    Glättet kleine Einbrüche ('valleys') in einem Höhenprofil z.
    """
    z = np.array(z).copy()
    rolling_min = pd.Series(z).rolling(window=window_size, center=True, min_periods=5).min()
    diff = rolling_min - z

    # Punkte mit tieferem Einbruch als erlaubt
    valley_mask = (diff > depth_threshold)
    z[valley_mask] = np.nan

    z_filled = interpolate_limited_nans(z, max_gap=max_gap)

    # Optional glätten
    if smoothing and z_filled is not None and np.count_nonzero(~np.isnan(z_filled)) > smooth_window:
        z_filled = savgol_filter(z_filled, window_length=smooth_window, polyorder=2)

    return z_filled
\end{lstlisting}
